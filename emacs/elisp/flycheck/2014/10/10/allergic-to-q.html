<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>Allergic to Q</title>
    <meta name="description" content="Personal blog of Charlie Andrews.
">

    <link href='https://fonts.googleapis.com/css?family=Sorts+Mill+Goudy:400,400italic|Inconsolata:400,700|Raleway' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://zeptonaut.com/emacs/elisp/flycheck/2014/10/10/allergic-to-q.html">
    <link rel="alternate" type="application/rss+xml" title="" href="http://zeptonaut.com/feed.xml">
    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-16399815-3', 'auto');
      ga('send', 'pageview');
    </script>
</head>


  <body>

    

    <div class="page-content">
      <div class="post">

  <header class="post-header">
    <h1 class="post-title">Allergic to Q</h1>
    <time>10/10/2014</time>
  </header>

  <article class="post-content">
    <p><a href="https://github.com/flycheck/flycheck">Flycheck</a> is a fantastic little emacs plugin that aims to help you find basic errors that can be found through static analysis. On its surface - yes, <em>I know</em> -this sounds incredibly boring. In practice, though, it’s often the most boring jobs that I <em>want</em> a computer to help with, in order to help conserve my precious little sanity.</p>

<p>You’re probably already familiar with what this looks like in practice. You know how in Microsoft Word and Google Docs, when you spell a word wrong, there’s a little red squiggly underneath the word? Think of flycheck as a customizable way to make those squigglies.</p>

<p>Today, I wanted to learn how to make an incredibly simple syntax checker. Well, really I started yesterday, but this “incredibly simple” checker actually took me two days to build because I’m an idiot. Typical.</p>

<p>This syntax checker will… (prepare yourself)… mark an error on any line with the letter ‘q’. Let’s get started.</p>

<p>First, get a copy of flycheck. You can do this using <code class="highlighter-rouge">package.el</code>, which is included in Emacs 24. <code class="highlighter-rouge">M-x package-install &lt;ENTER&gt; flycheck</code> should do the trick. If flycheck isn’t an available package, <a href="http://www.emacswiki.org/emacs/ELPA">make sure that you have the correct repositories set up</a>. Once you’ve done that, make sure that you require flycheck in your .emacs file by adding the following:</p>

<figure class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nb">require</span> <span class="ss">'flycheck</span><span class="p">)</span></code></pre></figure>

<p>Now that that’s taken care of, let’s figure out how a checker works in flycheck. Whenever I don’t have any clue what I’m doing (usually), I look for the simplest example that I can find. Luckily, flycheck is open source and has lots of checkers already defined, so we can just take a look at the <a href="https://github.com/flycheck/flycheck/blob/master/flycheck.el#L6327">main flycheck file in the github respository</a>. <code class="highlighter-rouge">yaml-jsyaml</code> looks like a simple enough checker:</p>

<figure class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">flycheck-define-checker</span> <span class="nv">yaml-jsyaml</span>
  <span class="s">"A YAML syntax checker using JS-YAML.

See URL `https://github.com/nodeca/js-yaml'."</span>
  <span class="ss">:command</span> <span class="p">(</span><span class="s">"js-yaml"</span> <span class="nv">source</span><span class="p">)</span>
  <span class="ss">:error-patterns</span>
  <span class="p">((</span><span class="nb">error</span> <span class="nv">line-start</span>
          <span class="s">"JS-YAML: "</span> <span class="p">(</span><span class="nv">message</span><span class="p">)</span> <span class="s">" at line "</span> <span class="nv">line</span> <span class="s">", column "</span> <span class="nv">column</span> <span class="s">":"</span>
          <span class="nv">line-end</span><span class="p">))</span>
  <span class="ss">:modes</span> <span class="nv">yaml-mode</span><span class="p">)</span></code></pre></figure>

<p>Let’s take this line by line:</p>

<figure class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="p">(</span><span class="nv">flycheck-define-checker</span> <span class="nv">yaml-jsyaml</span></code></pre></figure>

<p>This looks like it’s just a macro that creates the checker.</p>

<figure class="highlight"><pre><code class="language-elisp" data-lang="elisp">  <span class="ss">:command</span> <span class="p">(</span><span class="s">"js-yaml"</span> <span class="nv">source</span><span class="p">)</span></code></pre></figure>

<p>This looks like it’s telling flycheck the command to run to generate the list of errors. I’m assuming that js-yaml accepts a filename as its input, so <code class="highlighter-rouge">source</code> is probably just the name of the file being checked.</p>

<figure class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="ss">:error-patterns</span>
  <span class="p">((</span><span class="nb">error</span> <span class="nv">line-start</span>
          <span class="s">"JS-YAML: "</span> <span class="p">(</span><span class="nv">message</span><span class="p">)</span> <span class="s">" at line "</span> <span class="nv">line</span> <span class="s">", column "</span> <span class="nv">column</span> <span class="s">":"</span>
          <span class="nv">line-end</span><span class="p">))</span></code></pre></figure>

<p>This looks like it’s telling flycheck what a line of output text looks like. It looks like the error text is in the form:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>JS-YAML: This is an error message at line 43, column 2:
</code></pre>
</div>

<p>And lastly:</p>

<figure class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="ss">:modes</span> <span class="nv">yaml-mode</span><span class="p">)</span></code></pre></figure>

<p>Looks like it’s just telling flycheck what modes this checker is available in.</p>

<p>Great! Equipped with our new-found inkling of what to do, let’s try and write our own checker. This looks like a good framework:</p>

<figure class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="c1">;; ~/.emacs.d/playground/flycheck-error-on-q.el</span>

<span class="p">(</span><span class="nv">flycheck-define-checker</span> <span class="nv">error-on-q</span>
  <span class="s">"A syntax checker that errors on any line with a q."</span>

  <span class="ss">:command</span> <span class="p">(</span><span class="s">"TODO: Write the command"</span><span class="p">)</span>
  <span class="ss">:error-patterns</span>
  <span class="c1">;; Example error: 43:This line is bad</span>
  <span class="p">((</span><span class="nb">error</span> <span class="nv">line-start</span> <span class="nv">line</span> <span class="s">":"</span> <span class="p">(</span><span class="nv">message</span><span class="p">)</span> <span class="nv">line-end</span><span class="p">))</span>
  <span class="ss">:modes</span> <span class="nv">text-mode</span><span class="p">)</span>

<span class="p">(</span><span class="nb">provide</span> <span class="ss">'flycheck-error-on-q</span><span class="p">)</span></code></pre></figure>

<p>So now we just need to use our command-line-fu to write a one-liner that finds instances of the letter Q. To the terminal!</p>

<p>First, it’s probably a decent idea to think of a file that has some Q’s in it. In my case, I know that my Emacs initialization file has lots of them - it uses <code class="highlighter-rouge">package.el</code>’s <code class="highlighter-rouge">require</code> function a lot.</p>

<p><code class="highlighter-rouge">grep</code> is good at finding things and, with a bit of fooling around, I found that:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">grep --color<span class="o">=</span>never -n -i <span class="s2">"q"</span> <span class="nv">$FILENAME</span></code></pre></figure>

<p>finds the line with Q’s in them. This command makes sure:</p>

<ul>
  <li><code class="highlighter-rouge">--color=never</code>: We don’t colorize the output of <code class="highlighter-rouge">grep</code>. This ensures that we don’t insert any control characters into our output that might mess up the error parsing in our checker.</li>
  <li><code class="highlighter-rouge">-n</code>: We print the line number so that our checker knows which line to mark as erroneous.</li>
  <li><code class="highlighter-rouge">-i</code>: We accept both upper and lower case q’s</li>
</ul>

<p>Running this on my .emacs file with <code class="highlighter-rouge">grep --color=never -n -i "q" ~/.emacs</code>, I get</p>

<div class="highlighter-rouge"><pre class="highlight"><code>2:;; Required here because this is what allows requiring of other packages.
3:(require 'package)
4:(setq package-archives '(("gnu" . "http://elpa.gnu.org/packages/")
...
292:(require 'flycheck-error-on-q)
293:(add-to-list 'flycheck-checkers 'error-on-q)
</code></pre>
</div>

<p>Looks like a good start. Notice, though, that our checker expects a message after the colon, while <code class="highlighter-rouge">grep</code> just prints the matching string. We can fix this with a bit of <code class="highlighter-rouge">awk</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">grep --color<span class="o">=</span>never -n -i <span class="s2">"q"</span> <span class="nv">$FILENAME</span> | awk -F <span class="s2">":"</span> <span class="s1">'{print $1":Ick! Q! I hate that letter!"}'</span></code></pre></figure>

<p>Now, instead of <code class="highlighter-rouge">2:;; Required here because this is what allows requiring of other packages.</code>, we get <code class="highlighter-rouge">2:Ick! Q! I hate that letter!</code>.</p>

<p>Unfortunately, after trying, I realized that we can’t just put this incantation as our flycheck <code class="highlighter-rouge">:command</code> for two reasons:</p>

<ul>
  <li>Flycheck expects the return value of the command that’s run to be 1 if an error exists and 0 if it does not. For our command, it’ll always return 0 because awk is always successful.</li>
  <li>Flycheck automatically quotes all parameters after the first one, so it’d automatically quote <code class="highlighter-rouge">awk</code> as well as the pipe that follows it. We don’t want these evaluated as strings - we want them evaluated as regular old operations.</li>
</ul>

<p>Fortunately, all of these problems can be avoided by writing a thin wrapper of a bash script around our existing command. This bash script looks something like:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c">#!/bin/bash</span>
<span class="c"># ~/.emacs.d/playground/error-on-q</span>

<span class="c"># Capture the first argument and put it into $FILE</span>
<span class="nv">FILE</span><span class="o">=</span><span class="nv">$1</span>

<span class="c"># Capture the output of grep and put it into $MATCHES</span>
<span class="c"># Parameters:</span>
<span class="c"># --color=never  Don't colorize the output - we want plain text</span>
<span class="c"># -n             Print the line number of the match</span>
<span class="c"># -i             We don't care about the case of the letter</span>
<span class="c"># "q"            Our search string - the letter 'q'</span>
<span class="c"># $FILE          The file to search</span>
<span class="nv">MATCHES</span><span class="o">=</span><span class="k">$(</span>grep --color<span class="o">=</span>never -i -n <span class="s2">"q"</span> <span class="nv">$FILE</span><span class="k">)</span>

<span class="c"># Capture the output status of grep so we know if we found any q's</span>
<span class="nv">GREP_EXIT_STATUS</span><span class="o">=</span><span class="nv">$?</span>

<span class="k">if</span> <span class="o">[</span> <span class="nv">$GREP_EXIT_STATUS</span> -eq 0 <span class="o">]</span>; <span class="k">then</span>
  <span class="c"># Print output in the form file:line_no:Ick! Q! I hate that letter!</span>
  <span class="nb">echo</span> <span class="s2">"</span><span class="nv">$MATCHES</span><span class="s2">"</span> | awk -F <span class="s2">":"</span> <span class="s1">'{print $1":Ick! Q! I hate that letter!"}'</span>

  <span class="c"># If we found a 'q', return 1 to indicate there was a problem</span>
  <span class="c"># with the file</span>
  <span class="nb">exit </span>1;
<span class="k">else</span>
  <span class="c"># Otherwise, return 0</span>
  <span class="nb">exit </span>0;
<span class="k">fi</span></code></pre></figure>

<p>It’s long, but if you look at what it’s actually doing, it’s pretty simple. It’s running the commands that we already talked about with one modification: it’s capturing the exit value of <code class="highlighter-rouge">grep</code> and inverting it. That is, if <code class="highlighter-rouge">grep</code> returns 0, it returns 1, and vice versa. This is because we have an error when we find a Q, whereas grep returns 1 unless a match is found. <code class="highlighter-rouge">grep</code>’s error is our success.</p>

<p>I put this file at <code class="highlighter-rouge">~/.emacs.d/playground/error-on-q</code> and made sure it was executable with <code class="highlighter-rouge">chmod 755 ~/.emacs.d/playground/error-on-q</code>.</p>

<p>Now, we can use this script in our <code class="highlighter-rouge">:command</code> in our checker:</p>

<figure class="highlight"><pre><code class="language-elisp" data-lang="elisp"><span class="c1">;; ~/.emacs.d/playground/flycheck-error-on-q.el</span>

<span class="p">(</span><span class="nv">flycheck-define-checker</span> <span class="nv">error-on-q</span>
  <span class="s">"A syntax checker that always says that line 1 has an error."</span>

  <span class="ss">:command</span> <span class="p">(</span><span class="s">"~/.emacs.d/playground/error-on-q"</span> <span class="nv">source</span><span class="p">)</span>
  <span class="ss">:error-patterns</span>
  <span class="p">((</span><span class="nb">error</span> <span class="nv">line-start</span> <span class="nv">line</span> <span class="s">":"</span> <span class="p">(</span><span class="nv">message</span><span class="p">)</span> <span class="nv">line-end</span><span class="p">))</span>
  <span class="ss">:modes</span> <span class="nv">text-mode</span><span class="p">)</span>

<span class="p">(</span><span class="nb">provide</span> <span class="ss">'flycheck-error-on-q</span><span class="p">)</span></code></pre></figure>

<p>If we reevaluate the buffer and go back to our text buffer, we should see something like:</p>

<p><img src="/assets/error-on-q.gif" alt="error-on-q" /></p>

<p>Success!</p>

  </article>
  <a href="/index.html">« Back</a>
</div>

    </div>

    <link rel="alternate" type="application/rss+xml" title="" href="http://zeptonaut.com/feed.xml">


  </body>

</html>
